/**
 * @fileoverview SmartTable component for displaying business ideas with real-time updates
 *
 * This component provides a sophisticated table interface for viewing and interacting with
 * business ideas generated by the AI system. It supports real-time streaming updates,
 * loading states, visual enhancements, and interactive features.
 */

import { useState, useEffect, useRef, useMemo } from "react";
import { Card, CardContent } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { SmartTableSkeleton } from "../SmartTableSkeleton";
import { useWebSocketContext } from "@/contexts/WebSocketContext";
import { useDocumentationViewer } from '@/hooks/useDocumentationViewer';
import { MarkdownViewerModal } from '../MarkdownViewerModal';
import { ideasApi } from "@/services/ideas-api";
import "@/styles/smart-table.css";

// Hooks
import { useIdeaEventProcessor } from "@/hooks/useIdeaEventProcessor";
import { useTableSelection } from "@/hooks/useTableSelection";
import { useIdeaFiltering } from "@/hooks/useIdeaFiltering";

// Components
import { SmartTableHeader } from "./SmartTableHeader";
import { SmartTableToolbar } from "./SmartTableToolbar";
import { SmartTableRow } from "./SmartTableRow";
import { DeleteIdeasDialog } from "./DeleteIdeasDialog";

// Utils
import {
  formatOverallScoreMarkdown,
  formatCriticalAnalysisMarkdown,
  formatCompetitorAnalysisMarkdown,
} from "@/utils/smart-table-markdown";

// Types
import type { BusinessIdea } from "@/types/business-idea";
import type { SmartTableProps, ExecutionModeFilter } from "@/types/smart-table.types";

export function SmartTable({
  className,
  isActive,
}: SmartTableProps) {
  // State management
  const [showCurrentRun, setShowCurrentRun] = useState(false);
  const [showStarredOnly, setShowStarredOnly] = useState(false);
  const [executionModeFilter, setExecutionModeFilter] = useState<ExecutionModeFilter>('all');
  const [starredIdeas, setStarredIdeas] = useState<Set<string>>(new Set());
  const [newIdeaIds, setNewIdeaIds] = useState<Set<string>>(new Set());
  const [consolidatedReportEnabled, setConsolidatedReportEnabled] = useState(false);
  const [consolidatedReportPath, setConsolidatedReportPath] = useState<string | null>(null);
  const [databaseIdeas, setDatabaseIdeas] = useState<BusinessIdea[]>([]);
  const [isDatabaseLoading, setIsDatabaseLoading] = useState(false);
  const prevIdeasRef = useRef<BusinessIdea[]>([]);
  
  // Field detail modal state
  const [fieldModalOpen, setFieldModalOpen] = useState(false);
  const [fieldModalContent, setFieldModalContent] = useState<string>('');
  const [fieldModalTitle, setFieldModalTitle] = useState<string>('');
  
  // Hooks
  const { events, subscribe, unsubscribe, clearEvents } = useWebSocketContext();
  const { isOpen, content, isLoading: docLoading, openDocumentation, closeDocumentation } = useDocumentationViewer();
  
  // Process WebSocket events into ideas
  const ideas = useIdeaEventProcessor(
    events,
    starredIdeas,
    setConsolidatedReportEnabled,
    setConsolidatedReportPath
  );
  
  // Subscribe to agents when component is active
  useEffect(() => {
    if (isActive) {
      subscribe("IdeationAgent");
      subscribe("CompetitorAgent");
      subscribe("CriticAgent");
      subscribe("DocumentationAgent");
      clearEvents();
      setConsolidatedReportPath(null);
      setConsolidatedReportEnabled(false);
      setShowCurrentRun(true);
    } else {
      if (!showCurrentRun) {
        setIsDatabaseLoading(true);
        ideasApi.getIdeas(showStarredOnly ? true : undefined)
          .then(response => {
            setDatabaseIdeas(response.ideas);
            const starredSet = new Set(response.ideas.filter(idea => idea.starred).map(idea => idea.id));
            setStarredIdeas(starredSet);
          })
          .catch(error => {
            console.error('[SmartTable] Error refreshing ideas from database:', error);
          })
          .finally(() => {
            setIsDatabaseLoading(false);
          });
      }
    }
    return () => {
      unsubscribe("IdeationAgent");
      unsubscribe("CompetitorAgent");
      unsubscribe("CriticAgent");
      unsubscribe("DocumentationAgent");
    };
  }, [isActive, subscribe, unsubscribe, clearEvents, showCurrentRun, showStarredOnly]);
  
  // Load ideas from database
  useEffect(() => {
    if (!showCurrentRun) {
      setIsDatabaseLoading(true);
      ideasApi.getIdeas(showStarredOnly ? true : undefined)
        .then(response => {
          setDatabaseIdeas(response.ideas);
          const starredSet = new Set(response.ideas.filter(idea => idea.starred).map(idea => idea.id));
          setStarredIdeas(starredSet);
        })
        .catch(error => {
          console.error('[SmartTable] Error loading ideas from database:', error);
        })
        .finally(() => {
          setIsDatabaseLoading(false);
        });
    }
  }, [showCurrentRun, showStarredOnly]);
  
  // Determine which ideas to display
  const displayIdeas = showCurrentRun ? ideas : databaseIdeas;
  
  // Filter ideas
  const filteredIdeas = useIdeaFiltering(
    displayIdeas,
    showCurrentRun,
    showStarredOnly,
    executionModeFilter,
    starredIdeas
  );
  
  // Selection management
  const {
    selectedIds,
    isDeleting,
    deleteDialogOpen,
    allSelected,
    someSelected,
    handleSelectAll,
    handleSelectIdea,
    handleBulkDelete,
    setDeleteDialogOpen,
  } = useTableSelection(filteredIdeas, showCurrentRun, setDatabaseIdeas);
  
  // Loading and streaming states
  const loading = useMemo(() => {
    return isActive && ideas.length === 0;
  }, [isActive, ideas.length]);

  const isStreaming = useMemo(() => {
    const statusEvents = events.filter(e => e.agentName === 'Orchestrator' && e.type === 'status');
    const lastStatus = statusEvents[statusEvents.length - 1];
    return isActive && lastStatus?.message !== 'âœ… Agent chain completed successfully!';
  }, [events, isActive]);
  
  const isLoading = loading || isDatabaseLoading;
  
  // Star toggle handler
  const toggleStar = async (id: string) => {
    const isStarred = starredIdeas.has(id);
    
    // Optimistically update UI
    setStarredIdeas(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
    
    // Update database ideas if not in current run mode
    if (!showCurrentRun) {
      setDatabaseIdeas(prev => {
        const updated = prev.map(idea =>
          idea.id === id ? { ...idea, starred: !isStarred } : idea
        );
        return updated;
      });
    }
    
    // Persist to database
    try {
      await ideasApi.updateStarred(id, !isStarred);
    } catch (error) {
      console.error('[SmartTable] Error updating starred status:', error);
      // Revert on error
      setStarredIdeas(prev => {
        const newSet = new Set(prev);
        if (isStarred) {
          newSet.add(id);
        } else {
          newSet.delete(id);
        }
        return newSet;
      });
      
      if (!showCurrentRun) {
        setDatabaseIdeas(prev => prev.map(idea =>
          idea.id === id ? { ...idea, starred: isStarred } : idea
        ));
      }
    }
  };
  
  // Track newly added ideas for animation
  useEffect(() => {
    const prevIds = new Set(prevIdeasRef.current.map(idea => idea.id));
    const newIds = new Set<string>();

    ideas.forEach(idea => {
      if (!prevIds.has(idea.id)) {
        newIds.add(idea.id);
      }
    });

    if (newIds.size > 0) {
      setNewIdeaIds(newIds);
      setTimeout(() => setNewIdeaIds(new Set()), 2000);
    }

    prevIdeasRef.current = ideas;
  }, [ideas]);
  
  // Event handlers
  const handleViewConsolidatedReport = () => {
    if (!consolidatedReportPath) {
      console.error('[SmartTable] No consolidated report path available');
      return;
    }
    const pathParts = consolidatedReportPath.split('/');
    const reportId = pathParts[pathParts.length - 1];
    openDocumentation(reportId);
  };
  
  // Double-click handlers for modals
  const handleScoreDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Overall Score - ${idea.title}`);
    setFieldModalContent(formatOverallScoreMarkdown(idea));
    setFieldModalOpen(true);
  };

  const handleCriticalDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Critical Analysis - ${idea.title}`);
    setFieldModalContent(formatCriticalAnalysisMarkdown(idea));
    setFieldModalOpen(true);
  };

  const handleCompetitorDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Competitor Analysis - ${idea.title}`);
    setFieldModalContent(formatCompetitorAnalysisMarkdown(idea));
    setFieldModalOpen(true);
  };
  
  // Show skeleton loader when loading
  if (isLoading && filteredIdeas.length === 0) {
    return (
      <Card className={cn("shadow-elegant", className)}>
        <SmartTableSkeleton rows={5} showStreamingRow={isStreaming} />
      </Card>
    );
  }
  
  return (
    <>
      <Card className={cn("shadow-elegant", className)}>
        <SmartTableHeader
          filteredIdeasCount={filteredIdeas.length}
          isStreaming={isStreaming}
          consolidatedReportEnabled={consolidatedReportEnabled}
          onViewConsolidatedReport={handleViewConsolidatedReport}
          executionModeFilter={executionModeFilter}
          onExecutionModeFilterChange={setExecutionModeFilter}
          showStarredOnly={showStarredOnly}
          onShowStarredOnlyChange={setShowStarredOnly}
          showCurrentRun={showCurrentRun}
          onShowCurrentRunChange={setShowCurrentRun}
        />
        <CardContent className="p-0">
          <div className="smart-table-container">
            <Table className="smart-table">
              <TableHeader>
                <TableRow className="bg-muted/50">
                  <SmartTableToolbar
                    allSelected={allSelected}
                    someSelected={someSelected}
                    selectedCount={selectedIds.size}
                    onSelectAll={handleSelectAll}
                    onDeleteClick={() => setDeleteDialogOpen(true)}
                  />
                  <TableHead className="w-12"></TableHead>
                  <TableHead className="w-12">#</TableHead>
                  <TableHead className="min-w-[200px]">Idea</TableHead>
                  <TableHead className="w-32">Mode</TableHead>
                  <TableHead className="w-24">Overall</TableHead>
                  <TableHead className="w-24">Disruption</TableHead>
                  <TableHead className="w-24">Market</TableHead>
                  <TableHead className="w-24">Technical</TableHead>
                  <TableHead className="w-24">Capital</TableHead>
                  <TableHead className="w-24">Blue Ocean</TableHead>
                  <TableHead className="min-w-[150px]">Competitor Analysis</TableHead>
                  <TableHead className="min-w-[150px]">Critical Analysis</TableHead>
                  <TableHead className="w-32">Report</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredIdeas.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={14} className="text-center py-8 text-muted-foreground">
                      {isDatabaseLoading ? "Loading ideas from database..." :
                       isActive ? "Generating ideas..." :
                       showCurrentRun ? "No ideas generated yet. Start by filling out the form above." :
                       "No ideas found in the database."}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredIdeas.map((idea, index) => {
                    const isReportAvailable = !!idea.reportPath || !showCurrentRun;
                    
                    return (
                      <SmartTableRow
                        key={idea.id}
                        idea={idea}
                        index={index}
                        isSelected={selectedIds.has(idea.id)}
                        isNew={newIdeaIds.has(idea.id)}
                        isReportAvailable={isReportAvailable}
                        docLoading={docLoading}
                        onSelect={handleSelectIdea}
                        onToggleStar={toggleStar}
                        onScoreDoubleClick={() => handleScoreDoubleClick(idea)}
                        onCriticalDoubleClick={() => handleCriticalDoubleClick(idea)}
                        onCompetitorDoubleClick={() => handleCompetitorDoubleClick(idea)}
                        onOpenDocumentation={openDocumentation}
                      />
                    );
                  })
                )}
                {isStreaming && ideas.length > 0 && (
                  <TableRow className="bg-blue-50/50 animate-pulse">
                    <TableCell colSpan={14} className="text-center py-2">
                      <div className="flex items-center justify-center gap-2">
                        <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                        <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                        <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                        <span className="text-sm text-blue-600 ml-2">Analysis in progress...</span>
                      </div>
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
      
      <MarkdownViewerModal
        isOpen={isOpen}
        title="Business Idea Documentation"
        content={content}
        onClose={closeDocumentation}
      />
      
      <MarkdownViewerModal
        isOpen={fieldModalOpen}
        title={fieldModalTitle}
        content={fieldModalContent}
        onClose={() => setFieldModalOpen(false)}
      />
      
      <DeleteIdeasDialog
        open={deleteDialogOpen}
        onOpenChange={setDeleteDialogOpen}
        selectedCount={selectedIds.size}
        isDeleting={isDeleting}
        onDelete={handleBulkDelete}
      />
    </>
  );
}