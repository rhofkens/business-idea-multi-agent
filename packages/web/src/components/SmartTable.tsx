/**
 * @fileoverview SmartTable component for displaying business ideas with real-time updates
 *
 * This component provides a sophisticated table interface for viewing and interacting with
 * business ideas generated by the AI system. It supports real-time streaming updates,
 * loading states, visual enhancements, and interactive features. It now follows the robust
 * event handling pattern established by the TerminalOutput component.
 */

import { useState, useEffect, useRef, useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from "@/components/ui/table";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import {
  Star,
  Info,
  FileText,
  Filter,
  TrendingUp,
  Target,
  Cpu,
  DollarSign,
  Waves,
  Building,
  Database,
  Trash2,
  ChevronDown
} from "lucide-react";
import { SmartTableSkeleton } from "./SmartTableSkeleton";
import { useWebSocketContext } from "@/contexts/WebSocketContext";
import { transformBusinessIdea } from "@/utils/idea-transformer";
import type { BusinessIdea } from "@/types/business-idea";
import { businessIdeaSchema, type WorkflowEvent } from "@business-idea/shared";
import { z } from "zod";
import "@/styles/smart-table.css";
import { useDocumentationViewer } from '@/hooks/useDocumentationViewer';
import { MarkdownViewerModal } from './MarkdownViewerModal';
import { ideasApi } from "@/services/ideas-api";

interface SmartTableProps {
  className?: string;
  isActive: boolean;
}

// Create a specific type for the idea data within the event
const ideaDataSchema = z.object({
  idea: businessIdeaSchema,
});

// Create a more specific event type for results containing an idea
type IdeaWorkflowEvent = Omit<WorkflowEvent, 'metadata'> & {
  metadata: {
    data: z.infer<typeof ideaDataSchema>;
  }
};

const ScoreIcon = {
  overall: TrendingUp,
  disruption: Waves,
  market: Target,
  technical: Cpu,
  capital: DollarSign,
  blueOcean: Building,
};

const getScoreColor = (score: number | null) => {
  if (score === null) return "text-muted-foreground";
  if (score >= 7) return "text-score-high";
  if (score >= 4) return "text-score-medium";
  return "text-score-low";
};

const getScoreBg = (score: number | null) => {
  if (score === null) return "bg-muted";
  if (score >= 7) return "bg-success/10";
  if (score >= 4) return "bg-warning/10";
  return "bg-destructive/10";
};

const truncateText = (text: string, length: number = 100) => {
  if (!text) return "Not available";
  return text.length > length ? `${text.substring(0, length)}...` : text;
};

export function SmartTable({
  className,
  isActive,
}: SmartTableProps) {
  const [showCurrentRun, setShowCurrentRun] = useState(false);
  const [showStarredOnly, setShowStarredOnly] = useState(false);
  const [executionModeFilter, setExecutionModeFilter] = useState<'all' | 'solopreneur' | 'classic-startup'>('all');
  const [starredIdeas, setStarredIdeas] = useState<Set<string>>(new Set());
  const [newIdeaIds, setNewIdeaIds] = useState<Set<string>>(new Set());
  const [consolidatedReportEnabled, setConsolidatedReportEnabled] = useState(false);
  const [consolidatedReportPath, setConsolidatedReportPath] = useState<string | null>(null);
  const [databaseIdeas, setDatabaseIdeas] = useState<BusinessIdea[]>([]);
  const [isDatabaseLoading, setIsDatabaseLoading] = useState(false);
  const prevIdeasRef = useRef<BusinessIdea[]>([]);
  
  // State for field detail modal
  const [fieldModalOpen, setFieldModalOpen] = useState(false);
  const [fieldModalContent, setFieldModalContent] = useState<string>('');
  const [fieldModalTitle, setFieldModalTitle] = useState<string>('');
  
  // State for multi-select and bulk actions
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const { events, subscribe, unsubscribe, clearEvents } = useWebSocketContext();
  const { isOpen, content, isLoading: docLoading, openDocumentation, closeDocumentation } = useDocumentationViewer();
  
  // Subscribe to the IdeationAgent, CompetitorAgent, CriticAgent, and DocumentationAgent when the component is active
  useEffect(() => {
    if (isActive) {
      subscribe("IdeationAgent");
      subscribe("CompetitorAgent");
      subscribe("CriticAgent");
      subscribe("DocumentationAgent");
      // When a new generation starts, we should clear out the old ideas and reset consolidated report state
      clearEvents();
      setConsolidatedReportPath(null);
      setConsolidatedReportEnabled(false);
      // Auto-switch to current run view when generation starts
      setShowCurrentRun(true);
    } else {
      // When generation completes, refresh database ideas if we're in database view
      if (!showCurrentRun) {
        setIsDatabaseLoading(true);
        ideasApi.getIdeas(showStarredOnly ? true : undefined)
          .then(response => {
            setDatabaseIdeas(response.ideas);
            const starredSet = new Set(response.ideas.filter(idea => idea.starred).map(idea => idea.id));
            setStarredIdeas(starredSet);
          })
          .catch(error => {
            console.error('[SmartTable] Error refreshing ideas from database:', error);
          })
          .finally(() => {
            setIsDatabaseLoading(false);
          });
      }
    }
    return () => {
      unsubscribe("IdeationAgent");
      unsubscribe("CompetitorAgent");
      unsubscribe("CriticAgent");
      unsubscribe("DocumentationAgent");
    };
  }, [isActive, subscribe, unsubscribe, clearEvents, showCurrentRun, showStarredOnly]);
  
  // Load ideas from database on mount and when toggled to database mode or starred filter changes
  useEffect(() => {
    if (!showCurrentRun) {
      setIsDatabaseLoading(true);
      ideasApi.getIdeas(showStarredOnly ? true : undefined)
        .then(response => {
          setDatabaseIdeas(response.ideas);
          // Update starred ideas based on database data
          const starredSet = new Set(response.ideas.filter(idea => idea.starred).map(idea => idea.id));
          setStarredIdeas(starredSet);
        })
        .catch(error => {
          console.error('[SmartTable] Error loading ideas from database:', error);
        })
        .finally(() => {
          setIsDatabaseLoading(false);
        });
    }
  }, [showCurrentRun, showStarredOnly]);
  
  // Memoize the transformation of events to ideas
  const ideas = useMemo(() => {
    const ideaMap = new Map<string, BusinessIdea>();
    
    // Define types for competitor data
    interface CompetitorData {
      competitorAnalysis: string;
      blueOceanScore: number;
    }
    
    interface CriticData {
      criticalAnalysis: string;
      overallScore: number;
      reasoning?: string;
    }
    
    interface DocumentationData {
      reportPath: string;
    }
    
    const competitorDataMap = new Map<string, CompetitorData>();
    const criticDataMap = new Map<string, CriticData>();
    const documentationDataMap = new Map<string, DocumentationData>();
    const relevantEvents = events.filter(
      (e): e is IdeaWorkflowEvent => {
        // Accept IdeationAgent result events
        if (e.agentName === "IdeationAgent" && e.type === "result" && e.metadata?.data) {
          // Use Zod to safely parse the data
          const parsed = ideaDataSchema.safeParse(e.metadata.data);
          return parsed.success;
        }
        // Accept CompetitorAgent progress events
        if (e.agentName === "CompetitorAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept CriticAgent workflow events
        if (e.agentName === "CriticAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept DocumentationAgent progress events (individual idea documentation updates)
        if (e.agentName === "DocumentationAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept DocumentationAgent result event (complete documentation workflow finished)
        if (e.agentName === "DocumentationAgent" && e.type === "result" && e.metadata?.data) {
          return true;
        }
        return false;
      }
    );

    for (const event of relevantEvents) {
      if (event.agentName === "IdeationAgent") {
        // No need for try-catch as Zod has already validated the structure
        const ideaData = event.metadata.data.idea;
        const transformedIdea = transformBusinessIdea(ideaData, 0, true);
        ideaMap.set(transformedIdea.id, transformedIdea);
      } else if (event.agentName === "CompetitorAgent" && event.type === "progress") {
        try {
          // Parse CompetitorAgent progress events
          const data = event.metadata?.data as {
            ideaId?: string;
            competitorCount?: number;
            totalIdeas?: number;
            analysis?: {
              ideaId?: string;
              ideaTitle?: string;
              analysis?: string;
              blueOceanScore?: number;
            };
          };
          // Check if this event contains competitor analysis data
          if (data?.analysis?.ideaId && data?.analysis?.analysis && typeof data?.analysis?.blueOceanScore === "number") {
            
            
            // Store the competitor analysis text and blue ocean score
            competitorDataMap.set(data.analysis.ideaId, {
              competitorAnalysis: data.analysis.analysis,
              blueOceanScore: data.analysis.blueOceanScore
            });
            console.log('[SmartTable] Stored competitor data for idea:', data.analysis.ideaId);
          }
        } catch (error) {
          console.error('Error processing CompetitorAgent event:', error);
        }
      } else if (event.agentName === "CriticAgent" && event.type === "progress") {
        console.log('[SmartTable] Received CriticAgent progress event:', event);
        try {
          // Cast metadata.data to include evaluation property
          const criticData = event.metadata?.data as {
            evaluation?: {
              ideaId?: string;
              criticalAnalysis?: string;
              overallScore?: number;
              reasoning?: {
                [key: string]: string;
              };
            };
            [key: string]: unknown;
          };

          // Check if this event contains critic evaluation data
          if (
            criticData?.evaluation?.ideaId &&
            criticData?.evaluation?.criticalAnalysis &&
            typeof criticData?.evaluation?.overallScore === "number"
          ) {
            const evaluation = criticData.evaluation;
            
            // Extract overall reasoning from the reasoning object
            const overallReasoning = evaluation.reasoning ?
              Object.entries(evaluation.reasoning)
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n\n') :
              undefined;
            
            // Store the critic evaluation data
            criticDataMap.set(evaluation.ideaId, {
              criticalAnalysis: evaluation.criticalAnalysis,
              overallScore: evaluation.overallScore,
              reasoning: overallReasoning
            });
            console.log('[SmartTable] Stored critic data for idea:', evaluation.ideaId, {
              criticalAnalysis: evaluation.criticalAnalysis.substring(0, 50) + '...',
              overallScore: evaluation.overallScore
            });
          } else {
            console.log('[SmartTable] CriticAgent event did not contain valid evaluation data', {
              hasMetadata: !!event.metadata,
              hasData: !!event.metadata?.data,
              hasEvaluation: !!criticData?.evaluation,
              evaluation: criticData?.evaluation
            });
          }
        } catch (error) {
          console.error('[SmartTable] Error processing CriticAgent event:', error);
        }
      } else if (event.agentName === "DocumentationAgent") {
        console.log('[SmartTable] Received DocumentationAgent event:', event.type, event);
        try {
          if (event.type === "progress") {
            // Parse DocumentationAgent progress events - contains individual idea documentation paths
            const progressData = event.metadata?.data as {
              ideaId?: string;
              index?: number;
              total?: number;
              title?: string;
              reportPath?: string;
              [key: string]: unknown;
            };
            
            // Store the individual report path for each idea
            if (progressData?.ideaId) {
              console.log('[SmartTable] DocumentationAgent progress:', progressData.ideaId, `${progressData.index}/${progressData.total}`, progressData.title, 'reportPath:', progressData.ideaId, '.md');
              
              // Map the reportPath to the idea ID
              documentationDataMap.set(progressData.ideaId, {
                reportPath: progressData.ideaId
              });
              
              console.log('[SmartTable] Stored documentation path for idea:', progressData.ideaId);
            }
          } else if (event.type === "result") {
            // Parse DocumentationAgent result events - contains the consolidated report path
            const resultData = event.metadata?.data as {
              reportPath?: string;
              ideasProcessed?: number;
              processingTime?: number;
              [key: string]: unknown;
            };
            // DocumentationAgent creates ONE consolidated report for ALL ideas
            if (resultData?.reportPath) {
              console.log('[SmartTable] DocumentationAgent result - consolidated report path:', resultData.reportPath);
              
              // Enable the consolidated report button and store the path (stripping .md extension for consistency)
              setConsolidatedReportEnabled(true);
              const pathWithoutExtension = resultData.reportPath.replace(/\.md$/, '');
              setConsolidatedReportPath(pathWithoutExtension);
              console.log('[SmartTable] Consolidated report ready at:', pathWithoutExtension);
            }
          }
        } catch (error) {
          console.error('[SmartTable] Error processing DocumentationAgent event:', error);
        }
      }
    }
    console.log('[SmartTable] IdeaMap size:', ideaMap.size);
    console.log('[SmartTable] CompetitorDataMap size:', competitorDataMap.size);
    console.log('[SmartTable] CompetitorDataMap entries:', Array.from(competitorDataMap.entries()));
    console.log('[SmartTable] CriticDataMap size:', criticDataMap.size);
    console.log('[SmartTable] CriticDataMap entries:', Array.from(criticDataMap.entries()));
    console.log('[SmartTable] DocumentationDataMap size:', documentationDataMap.size);
    console.log('[SmartTable] DocumentationDataMap entries:', Array.from(documentationDataMap.entries()));
    
    
    // Merge competitor data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking competitor data for idea:', id);
      const competitorData = competitorDataMap.get(id);
      if (competitorData) {
        console.log('[SmartTable] Found competitor data for idea:', id, competitorData);
        // Update the idea with competitor analysis data
        idea.competitorAnalysis = competitorData.competitorAnalysis;
        idea.scores.blueOcean = competitorData.blueOceanScore;
        // Add blue ocean reasoning if not already present
        if (!idea.reasoning.blueOcean) {
          idea.reasoning.blueOcean = 'Blue Ocean score calculated based on competitor analysis';
        }
        console.log('[SmartTable] Updated idea with competitor data:', idea);
      }
    });
    
    // Merge critic data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking critic data for idea:', id);
      const criticData = criticDataMap.get(id);
      if (criticData) {
        console.log('[SmartTable] Found critic data for idea:', id, criticData);
        // Update the idea with critic evaluation data
        idea.criticalAnalysis = criticData.criticalAnalysis;
        idea.scores.overall = criticData.overallScore;
        // Update overall reasoning if provided
        if (criticData.reasoning) {
          idea.reasoning.overall = criticData.reasoning;
        }
        console.log('[SmartTable] Updated idea with critic data:', idea);
      }
    });
    // Merge documentation data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking documentation data for idea:', id);
      const documentationData = documentationDataMap.get(id);
      if (documentationData) {
        console.log('[SmartTable] Found documentation data for idea:', id, documentationData);
        // Update the idea with documentation report path
        idea.reportPath = documentationData.reportPath;
        console.log('[SmartTable] Updated idea with documentation data:', idea);
      }
    });
    
    
    // Add starring status from local state
    const ideasWithStars = Array.from(ideaMap.values()).map(idea => ({
      ...idea,
      starred: starredIdeas.has(idea.id),
    }));

    // Sort by overall score descending, putting null scores last
    return ideasWithStars.sort((a, b) => {
      const scoreA = a.scores.overall ?? -1;
      const scoreB = b.scores.overall ?? -1;
      return scoreB - scoreA;
    });

  }, [events, starredIdeas]);

  const loading = useMemo(() => {
    // Loading is true if active and no ideas have been generated yet.
    return isActive && ideas.length === 0;
  }, [isActive, ideas.length]);

  const isStreaming = useMemo(() => {
    // Streaming is true if the process is active and we haven't received a final status event.
    const statusEvents = events.filter(e => e.agentName === 'Orchestrator' && e.type === 'status');
    const lastStatus = statusEvents[statusEvents.length - 1];
    console.log('[SmartTable] Orchestrator status event found, testing for completion message', lastStatus);
    console.log('[SmartTable] Received last event, returning streaming status');
    return isActive && lastStatus?.message !== '✅ Agent chain completed successfully!';
  }, [events, isActive]);


  const toggleStar = async (id: string) => {
    console.log('[SmartTable] toggleStar called for id:', id);
    console.log('[SmartTable] showCurrentRun:', showCurrentRun);
    
    const isStarred = starredIdeas.has(id);
    console.log('[SmartTable] Current starred status:', isStarred);
    console.log('[SmartTable] databaseIdeas before update:', databaseIdeas.map(idea => ({ id: idea.id, starred: idea.starred })));
    
    // Optimistically update UI
    setStarredIdeas(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      console.log('[SmartTable] Updated starredIdeas Set:', Array.from(newSet));
      return newSet;
    });
    
    // If viewing database ideas, also update the databaseIdeas array for immediate UI feedback
    if (!showCurrentRun) {
      console.log('[SmartTable] Updating databaseIdeas array...');
      setDatabaseIdeas(prev => {
        const updated = prev.map(idea =>
          idea.id === id ? { ...idea, starred: !isStarred } : idea
        );
        console.log('[SmartTable] databaseIdeas after update:', updated.map(idea => ({ id: idea.id, starred: idea.starred })));
        return updated;
      });
    }
    
    // Always persist to database
    try {
      await ideasApi.updateStarred(id, !isStarred);
      console.log('[SmartTable] API call successful');
    } catch (error) {
      console.error('[SmartTable] Error updating starred status:', error);
      // Revert starredIdeas Set on error
      setStarredIdeas(prev => {
        const newSet = new Set(prev);
        if (isStarred) {
          newSet.add(id);
        } else {
          newSet.delete(id);
        }
        return newSet;
      });
      
      // If in database mode, also revert databaseIdeas array
      if (!showCurrentRun) {
        setDatabaseIdeas(prev => prev.map(idea =>
          idea.id === id ? { ...idea, starred: isStarred } : idea
        ));
      }
    }
  };

  // Track newly added ideas for animation
  useEffect(() => {
    const prevIds = new Set(prevIdeasRef.current.map(idea => idea.id));
    const newIds = new Set<string>();

    ideas.forEach(idea => {
      if (!prevIds.has(idea.id)) {
        newIds.add(idea.id);
      }
    });

    if (newIds.size > 0) {
      setNewIdeaIds(newIds);
      setTimeout(() => setNewIdeaIds(new Set()), 2000);
    }

    prevIdeasRef.current = ideas;
  }, [ideas]);

  // Use live ideas when showCurrentRun is true, database ideas when false
  const displayIdeas = showCurrentRun ? ideas : databaseIdeas;
  
  console.log('[SmartTable] displayIdeas:', displayIdeas.map(idea => ({ id: idea.id, starred: idea.starred })));

  const filteredIdeas = displayIdeas.filter(idea => {
    // Apply current run filter if in current run mode
    if (showCurrentRun && !idea.isCurrentRun) return false;
    // Apply starred filter if enabled and in current run mode (database mode already filtered by API)
    if (showStarredOnly && showCurrentRun && !starredIdeas.has(idea.id)) return false;
    // Apply execution mode filter
    if (executionModeFilter !== 'all') {
      const ideaMode = idea.executionMode?.toLowerCase() || '';
      if (executionModeFilter === 'solopreneur') {
        // Check if it's solopreneur mode or similar (1-3 person team)
        if (!ideaMode.includes('solo') && !ideaMode.includes('1-') && !ideaMode.includes('2-') && !ideaMode.includes('3-') && ideaMode !== 'solopreneur') {
          return false;
        }
      } else if (executionModeFilter === 'classic-startup') {
        // Check if it's classic startup mode or larger team
        if (ideaMode.includes('solo') || ideaMode.includes('1-') || ideaMode.includes('2-') || ideaMode.includes('3-') || ideaMode === 'solopreneur') {
          return false;
        }
      }
    }
    return true;
  });

  const handleViewConsolidatedReport = () => {
    console.log('[SmartTable] View consolidated report clicked');
    if (!consolidatedReportPath) {
      console.error('[SmartTable] No consolidated report path available');
      return;
    }

    // Extract the filename (ID) from the full path
    // Note: .md extension already stripped when storing the path
    const pathParts = consolidatedReportPath.split('/');
    const reportId = pathParts[pathParts.length - 1];
    
    console.log('[SmartTable] Opening consolidated report:', reportId);
    openDocumentation(reportId);
  };

  // Multi-select handlers
  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const allIds = new Set(filteredIdeas.map(idea => idea.id));
      setSelectedIds(allIds);
    } else {
      setSelectedIds(new Set());
    }
  };

  const handleSelectIdea = (id: string, checked: boolean) => {
    setSelectedIds(prev => {
      const newSet = new Set(prev);
      if (checked) {
        newSet.add(id);
      } else {
        newSet.delete(id);
      }
      return newSet;
    });
  };

  const handleBulkDelete = async () => {
    if (selectedIds.size === 0) return;
    
    setIsDeleting(true);
    try {
      // Call API to delete selected ideas
      await ideasApi.deleteIdeas(Array.from(selectedIds));
      
      // Remove deleted ideas from database ideas
      if (!showCurrentRun) {
        setDatabaseIdeas(prev => prev.filter(idea => !selectedIds.has(idea.id)));
      }
      
      // Clear selection
      setSelectedIds(new Set());
      setDeleteDialogOpen(false);
    } catch (error) {
      console.error('[SmartTable] Error deleting ideas:', error);
    } finally {
      setIsDeleting(false);
    }
  };

  // Check if all visible ideas are selected
  const allSelected = filteredIdeas.length > 0 && filteredIdeas.every(idea => selectedIds.has(idea.id));
  const someSelected = filteredIdeas.some(idea => selectedIds.has(idea.id));

  // Format content for markdown display
  const formatOverallScoreMarkdown = (idea: BusinessIdea): string => {
    const scores = idea.scores;
    const reasoning = idea.reasoning;
    
    return `# Overall Score Analysis

## Score: ${scores.overall ? `${scores.overall.toFixed(1)}/10` : 'Pending'}

### Reasoning
${reasoning.overall || 'Overall analysis is being generated...'}

## Score Breakdown

| Metric | Score | Description |
|--------|-------|-------------|
| **Disruption Potential** | ${scores.disruption ? `${scores.disruption.toFixed(1)}/10` : 'Pending'} | ${reasoning.disruption || 'Analysis pending...'} |
| **Market Potential** | ${scores.market ? `${scores.market.toFixed(1)}/10` : 'Pending'} | ${reasoning.market || 'Analysis pending...'} |
| **Technical Complexity** | ${scores.technical ? `${scores.technical.toFixed(1)}/10` : 'Pending'} | ${reasoning.technical || 'Analysis pending...'} |
| **Capital Intensity** | ${scores.capital ? `${scores.capital.toFixed(1)}/10` : 'Pending'} | ${reasoning.capital || 'Analysis pending...'} |
| **Blue Ocean Score** | ${scores.blueOcean ? `${scores.blueOcean.toFixed(1)}/10` : 'Pending'} | ${reasoning.blueOcean || 'Analysis pending...'} |

## Business Details

**Title:** ${idea.title}

**Description:** ${idea.description}

**Business Model:** ${idea.businessModel}

**Execution Mode:** ${idea.executionMode || 'Not specified'}
`;
  };

  const formatCriticalAnalysisMarkdown = (idea: BusinessIdea): string => {
    return `# Critical Analysis

## ${idea.title}

### Analysis
${idea.criticalAnalysis || 'Critical analysis is being generated by the Business Critic Agent...'}

### Overall Score
${idea.scores.overall ? `**${idea.scores.overall.toFixed(1)}/10**` : 'Score pending...'}

${idea.reasoning.overall ? `#### Reasoning\n${idea.reasoning.overall}` : ''}

### Key Considerations
- **Market Potential:** ${idea.scores.market ? `${idea.scores.market}/10` : 'Pending'}
- **Technical Complexity:** ${idea.scores.technical ? `${idea.scores.technical}/10` : 'Pending'}
- **Capital Requirements:** ${idea.scores.capital ? `${idea.scores.capital}/10` : 'Pending'}
`;
  };

  const formatCompetitorAnalysisMarkdown = (idea: BusinessIdea): string => {
    return `# Competitor Analysis

## ${idea.title}

### Market Analysis
${idea.competitorAnalysis || 'Competitor analysis is being performed by the Competitor Agent...'}

### Blue Ocean Score
${idea.scores.blueOcean ? `**${idea.scores.blueOcean.toFixed(1)}/10**` : 'Score pending...'}

${idea.reasoning.blueOcean ? `#### Blue Ocean Reasoning\n${idea.reasoning.blueOcean}` : ''}

### Market Positioning
- **Disruption Potential:** ${idea.scores.disruption ? `${idea.scores.disruption}/10` : 'Pending'}
- **Market Saturation:** ${idea.scores.blueOcean ? (10 - idea.scores.blueOcean).toFixed(1) : 'N/A'}/10
`;
  };

  // Handlers for double-click actions
  const handleScoreDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Overall Score - ${idea.title}`);
    setFieldModalContent(formatOverallScoreMarkdown(idea));
    setFieldModalOpen(true);
  };

  const handleCriticalDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Critical Analysis - ${idea.title}`);
    setFieldModalContent(formatCriticalAnalysisMarkdown(idea));
    setFieldModalOpen(true);
  };

  const handleCompetitorDoubleClick = (idea: BusinessIdea) => {
    setFieldModalTitle(`Competitor Analysis - ${idea.title}`);
    setFieldModalContent(formatCompetitorAnalysisMarkdown(idea));
    setFieldModalOpen(true);
  };

  // Combine loading states
  const isLoading = loading || isDatabaseLoading;

  if (isLoading && filteredIdeas.length === 0) {
    return (
      <Card className={cn("shadow-elegant", className)}>
        <SmartTableSkeleton rows={5} showStreamingRow={isStreaming} />
      </Card>
    );
  }

  const renderScoreCell = (
    score: number | null | undefined,
    reasoning: string,
    type: keyof typeof ScoreIcon,
    onDoubleClick?: () => void
  ) => {
    const Icon = ScoreIcon[type];
    const isPending = score === null || score === undefined;
    
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div 
              className={cn(
                "score-cell flex items-center gap-1 px-2 py-1 rounded-md",
                onDoubleClick ? "cursor-pointer" : "cursor-help",
                isPending ? "loading-shimmer" : getScoreBg(score)
              )}
              onDoubleClick={onDoubleClick}
            >
              <Icon className={cn("h-3 w-3", isPending && "opacity-50")} />
              <span className={cn(
                "font-medium text-sm",
                isPending ? "text-muted-foreground" : getScoreColor(score)
              )}>
                {score !== null && score !== undefined ? score.toFixed(1) : "—"}
              </span>
              <Info className={cn(
                "h-3 w-3",
                isPending ? "opacity-50" : "text-muted-foreground"
              )} />
            </div>
          </TooltipTrigger>
          <TooltipContent className="max-w-xs">
            <p className="text-sm">{reasoning || "Analysis in progress..."}</p>
            {onDoubleClick && <p className="text-xs mt-1 text-muted-foreground">Double-click for details</p>}
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  };

  return (
    <>
      <Card className={cn("shadow-elegant", className)}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            Business Ideas Analysis
            <Badge variant="secondary" className={cn("ml-2", isStreaming && "isStreaming-pulse")}>
              {filteredIdeas.length} ideas
            </Badge>
            <Button
              variant="outline"
              size="sm"
              onClick={handleViewConsolidatedReport}
              disabled={!consolidatedReportEnabled}
              className="ml-2"
            >
              <FileText className="h-4 w-4 mr-2" />
              View consolidated report
            </Button>
          </CardTitle>
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-2">
              <Filter className="h-4 w-4 text-muted-foreground" />
              <Select value={executionModeFilter} onValueChange={(value: 'all' | 'solopreneur' | 'classic-startup') => setExecutionModeFilter(value)}>
                <SelectTrigger className="w-[160px] h-8">
                  <SelectValue placeholder="Filter by mode" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Ideas</SelectItem>
                  <SelectItem value="solopreneur">Solopreneur</SelectItem>
                  <SelectItem value="classic-startup">Classic Startup</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="flex items-center gap-2">
              <Star className={cn("h-4 w-4", showStarredOnly ? "text-yellow-500 fill-yellow-500" : "text-muted-foreground")} />
              <Label htmlFor="starred-toggle" className="text-sm">Starred only</Label>
              <Switch id="starred-toggle" checked={showStarredOnly} onCheckedChange={setShowStarredOnly} />
            </div>
            <div className="flex items-center gap-2">
              <Database className="h-4 w-4 text-muted-foreground" />
              <Label htmlFor="filter-toggle" className="text-sm">Live agent data</Label>
              <Switch id="filter-toggle" checked={showCurrentRun} onCheckedChange={setShowCurrentRun} />
            </div>
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-0">
        <div className="smart-table-container">
          <Table className="smart-table">
            <TableHeader>
              <TableRow className="bg-muted/50">
                <TableHead className="w-12">
                  <div className="flex items-center gap-1">
                    <Checkbox
                      checked={allSelected}
                      onCheckedChange={handleSelectAll}
                      aria-label="Select all"
                    />
                    {someSelected && (
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                            <ChevronDown className="h-3 w-3" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="start">
                          <DropdownMenuItem
                            onClick={() => setDeleteDialogOpen(true)}
                            className="text-destructive"
                          >
                            <Trash2 className="h-4 w-4 mr-2" />
                            Delete ({selectedIds.size})
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    )}
                  </div>
                </TableHead>
                <TableHead className="w-12"></TableHead>
                <TableHead className="w-12">#</TableHead>
                <TableHead className="min-w-[200px]">Idea</TableHead>
                <TableHead className="w-32">Mode</TableHead>
                <TableHead className="w-24">Overall</TableHead>
                <TableHead className="w-24">Disruption</TableHead>
                <TableHead className="w-24">Market</TableHead>
                <TableHead className="w-24">Technical</TableHead>
                <TableHead className="w-24">Capital</TableHead>
                <TableHead className="w-24">Blue Ocean</TableHead>
                <TableHead className="min-w-[150px]">Competitor Analysis</TableHead>
                <TableHead className="min-w-[150px]">Critical Analysis</TableHead>
                <TableHead className="w-32">Report</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredIdeas.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={14} className="text-center py-8 text-muted-foreground">
                    {isDatabaseLoading ? "Loading ideas from database..." :
                     isActive ? "Generating ideas..." :
                     showCurrentRun ? "No ideas generated yet. Start by filling out the form above." :
                     "No ideas found in the database."}
                  </TableCell>
                </TableRow>
              ) : (
                filteredIdeas.map((idea, index) => {
                  // Report is available if a path exists, or if we are viewing from the database
                  const isReportAvailable = idea.reportPath || !showCurrentRun;
                  
                  // Debug logging for star rendering
                  console.log('[SmartTable] Rendering idea:', { id: idea.id, starred: idea.starred, showCurrentRun });

                  return (
                    <TableRow
                      key={idea.id}
                      className={cn(
                        "hover:bg-muted/50 transition-colors",
                        newIdeaIds.has(idea.id) && "new-idea-glow",
                        selectedIds.has(idea.id) && "bg-muted/30"
                      )}
                    >
                      <TableCell>
                        <Checkbox
                          checked={selectedIds.has(idea.id)}
                          onCheckedChange={(checked) => handleSelectIdea(idea.id, checked as boolean)}
                          aria-label={`Select ${idea.title}`}
                        />
                      </TableCell>
                      <TableCell>
                        <Button variant="ghost" size="sm" onClick={() => toggleStar(idea.id)} className="h-8 w-8 p-0 group">
                          <Star className={cn("h-4 w-4 transition-colors", idea.starred ? "fill-yellow-400 text-yellow-400" : "text-muted-foreground group-hover:text-yellow-400")} />
                        </Button>
                      </TableCell>
                      <TableCell className="font-medium text-sm">{String(index + 1).padStart(2, '0')}</TableCell>
                      <TableCell>
                        <div className="space-y-1">
                          <div className="font-semibold text-sm">{idea.title}</div>
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild><div className="text-xs text-muted-foreground cursor-help">{truncateText(idea.description, 100)}</div></TooltipTrigger>
                              <TooltipContent className="max-w-md"><p>{idea.description}</p></TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        </div>
                      </TableCell>
                      <TableCell>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <Badge 
                                variant={
                                  idea.executionMode?.toLowerCase().includes('solo') || 
                                  idea.executionMode?.includes('1-') || 
                                  idea.executionMode?.includes('2-') || 
                                  idea.executionMode?.includes('3-') ||
                                  idea.executionMode === 'solopreneur' 
                                    ? 'secondary' 
                                    : 'default'
                                } 
                                className="whitespace-nowrap cursor-help"
                              >
                                {(() => {
                                  const mode = idea.executionMode?.toLowerCase() || '';
                                  if (mode === 'solopreneur' || mode.includes('solo')) return 'Solo';
                                  if (mode === 'classic-startup') return 'Startup';
                                  if (mode.includes('1-') || mode.includes('2-') || mode.includes('3-')) return 'Small Team';
                                  return 'Startup';
                                })()}
                              </Badge>
                            </TooltipTrigger>
                            <TooltipContent className="max-w-xs">
                              <p className="text-sm">{idea.executionMode || 'Not specified'}</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </TableCell>
                      <TableCell>{renderScoreCell(idea.scores.overall, idea.reasoning.overall, 'overall', () => handleScoreDoubleClick(idea))}</TableCell>
                      <TableCell>{renderScoreCell(idea.scores.disruption, idea.reasoning.disruption, 'disruption')}</TableCell>
                      <TableCell>{renderScoreCell(idea.scores.market, idea.reasoning.market, 'market')}</TableCell>
                      <TableCell>{renderScoreCell(idea.scores.technical, idea.reasoning.technical, 'technical')}</TableCell>
                      <TableCell>{renderScoreCell(idea.scores.capital, idea.reasoning.capital, 'capital')}</TableCell>
                      <TableCell>{renderScoreCell(idea.scores.blueOcean, idea.reasoning.blueOcean, 'blueOcean')}</TableCell>
                      <TableCell>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <div 
                                className="text-xs cursor-pointer hover:underline"
                                onDoubleClick={() => handleCompetitorDoubleClick(idea)}
                              >
                                {truncateText(idea.competitorAnalysis || "Analysis pending...")}
                              </div>
                            </TooltipTrigger>
                            <TooltipContent className="max-w-md">
                              <p>{idea.competitorAnalysis || "Competitor analysis is being generated..."}</p>
                              <p className="text-xs mt-1 text-muted-foreground">Double-click for full analysis</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </TableCell>
                      <TableCell>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <div 
                                className="text-xs cursor-pointer hover:underline"
                                onDoubleClick={() => handleCriticalDoubleClick(idea)}
                              >
                                {truncateText(idea.criticalAnalysis || "Analysis pending...")}
                              </div>
                            </TooltipTrigger>
                            <TooltipContent className="max-w-md">
                              <p>{idea.criticalAnalysis || "Critical analysis is being generated..."}</p>
                              <p className="text-xs mt-1 text-muted-foreground">Double-click for full analysis</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </TableCell>
                      <TableCell>
                        <Button
                          variant={isReportAvailable ? "outline" : "ghost"}
                          size="sm"
                          onClick={() => openDocumentation(idea.id)}
                          disabled={!isReportAvailable || docLoading}
                          className="h-8"
                        >
                          <FileText className="h-3 w-3 mr-1" />
                          {isReportAvailable ? "View" : "Pending"}
                        </Button>
                      </TableCell>
                    </TableRow>
                  );
                })
              )}
              {isStreaming && ideas.length > 0 && (
                <TableRow className="bg-blue-50/50 animate-pulse">
                  <TableCell colSpan={14} className="text-center py-2">
                    <div className="flex items-center justify-center gap-2">
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                      <span className="text-sm text-blue-600 ml-2">Analysis in progress...</span>
                    </div>
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
    
    <MarkdownViewerModal
      isOpen={isOpen}
      title="Business Idea Documentation"
      content={content}
      onClose={closeDocumentation}
    />
    
    <MarkdownViewerModal
      isOpen={fieldModalOpen}
      title={fieldModalTitle}
      content={fieldModalContent}
      onClose={() => setFieldModalOpen(false)}
    />
    
    <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Ideas</AlertDialogTitle>
          <AlertDialogDescription>
            Are you sure you want to delete {selectedIds.size} selected idea{selectedIds.size !== 1 ? 's' : ''}? 
            This action cannot be undone.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction 
            onClick={handleBulkDelete} 
            disabled={isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting ? "Deleting..." : "Delete"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
    </>
  );
}