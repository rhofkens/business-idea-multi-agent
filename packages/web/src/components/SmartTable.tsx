/**
 * @fileoverview SmartTable component for displaying business ideas with real-time updates
 *
 * This component provides a sophisticated table interface for viewing and interacting with
 * business ideas generated by the AI system. It supports real-time streaming updates,
 * loading states, visual enhancements, and interactive features. It now follows the robust
 * event handling pattern established by the TerminalOutput component.
 */

import { useState, useEffect, useRef, useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from "@/components/ui/table";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import {
  Star,
  Info,
  FileText,
  Filter,
  TrendingUp,
  Target,
  Cpu,
  DollarSign,
  Waves,
  Building
} from "lucide-react";
import { SmartTableSkeleton } from "./SmartTableSkeleton";
import { useWebSocketContext } from "@/contexts/WebSocketContext";
import { transformBusinessIdea } from "@/utils/idea-transformer";
import type { BusinessIdea } from "@/types/business-idea";
import { businessIdeaSchema, type WorkflowEvent } from "@business-idea/shared";
import { z } from "zod";
import "@/styles/smart-table.css";
import { useDocumentationViewer } from '@/hooks/useDocumentationViewer';
import { MarkdownViewerModal } from './MarkdownViewerModal';

interface SmartTableProps {
  className?: string;
  isActive: boolean;
}

// Create a specific type for the idea data within the event
const ideaDataSchema = z.object({
  idea: businessIdeaSchema,
});

// Create a more specific event type for results containing an idea
type IdeaWorkflowEvent = Omit<WorkflowEvent, 'metadata'> & {
  metadata: {
    data: z.infer<typeof ideaDataSchema>;
  }
};

const ScoreIcon = {
  overall: TrendingUp,
  disruption: Waves,
  market: Target,
  technical: Cpu,
  capital: DollarSign,
  blueOcean: Building,
};

const getScoreColor = (score: number | null) => {
  if (score === null) return "text-muted-foreground";
  if (score >= 7) return "text-score-high";
  if (score >= 4) return "text-score-medium";
  return "text-score-low";
};

const getScoreBg = (score: number | null) => {
  if (score === null) return "bg-muted";
  if (score >= 7) return "bg-success/10";
  if (score >= 4) return "bg-warning/10";
  return "bg-destructive/10";
};

const truncateText = (text: string, length: number = 100) => {
  if (!text) return "Not available";
  return text.length > length ? `${text.substring(0, length)}...` : text;
};

export function SmartTable({
  className,
  isActive,
}: SmartTableProps) {
  const [showCurrentRun, setShowCurrentRun] = useState(true);
  const [starredIdeas, setStarredIdeas] = useState<Set<string>>(new Set());
  const [newIdeaIds, setNewIdeaIds] = useState<Set<string>>(new Set());
  const [consolidatedReportEnabled, setConsolidatedReportEnabled] = useState(false);
  const [consolidatedReportPath, setConsolidatedReportPath] = useState<string | null>(null);
  const prevIdeasRef = useRef<BusinessIdea[]>([]);

  const { events, subscribe, unsubscribe, clearEvents } = useWebSocketContext();
  const { isOpen, content, isLoading: docLoading, error: docError, openDocumentation, closeDocumentation } = useDocumentationViewer();
  
  // Subscribe to the IdeationAgent, CompetitorAgent, CriticAgent, and DocumentationAgent when the component is active
  useEffect(() => {
    if (isActive) {
      subscribe("IdeationAgent");
      subscribe("CompetitorAgent");
      subscribe("CriticAgent");
      subscribe("DocumentationAgent");
      // When a new generation starts, we should clear out the old ideas and reset consolidated report state
      clearEvents();
      setConsolidatedReportPath(null);
      setConsolidatedReportEnabled(false);
    }
    return () => {
      unsubscribe("IdeationAgent");
      unsubscribe("CompetitorAgent");
      unsubscribe("CriticAgent");
      unsubscribe("DocumentationAgent");
    };
  }, [isActive, subscribe, unsubscribe, clearEvents]);
  
  // Memoize the transformation of events to ideas
  const ideas = useMemo(() => {
    const ideaMap = new Map<string, BusinessIdea>();
    
    // Define types for competitor data
    interface CompetitorInfo {
      name: string;
      description: string;
    }
    
    interface CompetitorData {
      competitorAnalysis: string;
      blueOceanScore: number;
    }
    
    interface CriticData {
      criticalAnalysis: string;
      overallScore: number;
      reasoning?: string;
    }
    
    interface DocumentationData {
      reportPath: string;
    }
    
    const competitorDataMap = new Map<string, CompetitorData>();
    const criticDataMap = new Map<string, CriticData>();
    const documentationDataMap = new Map<string, DocumentationData>();
    const relevantEvents = events.filter(
      (e): e is IdeaWorkflowEvent => {
        // Accept IdeationAgent result events
        if (e.agentName === "IdeationAgent" && e.type === "result" && e.metadata?.data) {
          // Use Zod to safely parse the data
          const parsed = ideaDataSchema.safeParse(e.metadata.data);
          return parsed.success;
        }
        // Accept CompetitorAgent progress events
        if (e.agentName === "CompetitorAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept CriticAgent workflow events
        if (e.agentName === "CriticAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept DocumentationAgent progress events (individual idea documentation updates)
        if (e.agentName === "DocumentationAgent" && e.type === "progress" && e.metadata?.data) {
          return true;
        }
        // Accept DocumentationAgent result event (complete documentation workflow finished)
        if (e.agentName === "DocumentationAgent" && e.type === "result" && e.metadata?.data) {
          return true;
        }
        return false;
      }
    );

    for (const event of relevantEvents) {
      if (event.agentName === "IdeationAgent") {
        // No need for try-catch as Zod has already validated the structure
        const ideaData = event.metadata.data.idea;
        const transformedIdea = transformBusinessIdea(ideaData, 0, true);
        ideaMap.set(transformedIdea.id, transformedIdea);
      } else if (event.agentName === "CompetitorAgent" && event.type === "progress") {
        try {
          // Parse CompetitorAgent progress events
          const data = event.metadata?.data as {
            ideaId?: string;
            competitorCount?: number;
            totalIdeas?: number;
            analysis?: {
              ideaId?: string;
              ideaTitle?: string;
              analysis?: string;
              blueOceanScore?: number;
            };
          };
          // Check if this event contains competitor analysis data
          if (data?.analysis?.ideaId && data?.analysis?.analysis && typeof data?.analysis?.blueOceanScore === "number") {
            
            
            // Store the competitor analysis text and blue ocean score
            competitorDataMap.set(data.analysis.ideaId, {
              competitorAnalysis: data.analysis.analysis,
              blueOceanScore: data.analysis.blueOceanScore
            });
            console.log('[SmartTable] Stored competitor data for idea:', data.analysis.ideaId);
          }
        } catch (error) {
          console.error('Error processing CompetitorAgent event:', error);
        }
      } else if (event.agentName === "CriticAgent" && event.type === "progress") {
        console.log('[SmartTable] Received CriticAgent progress event:', event);
        try {
          // Cast metadata.data to include evaluation property
          const criticData = event.metadata?.data as {
            evaluation?: {
              ideaId?: string;
              criticalAnalysis?: string;
              overallScore?: number;
              reasoning?: {
                [key: string]: string;
              };
            };
            [key: string]: unknown;
          };

          // Check if this event contains critic evaluation data
          if (
            criticData?.evaluation?.ideaId &&
            criticData?.evaluation?.criticalAnalysis &&
            typeof criticData?.evaluation?.overallScore === "number"
          ) {
            const evaluation = criticData.evaluation;
            
            // Extract overall reasoning from the reasoning object
            const overallReasoning = evaluation.reasoning ?
              Object.entries(evaluation.reasoning)
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n\n') :
              undefined;
            
            // Store the critic evaluation data
            criticDataMap.set(evaluation.ideaId, {
              criticalAnalysis: evaluation.criticalAnalysis,
              overallScore: evaluation.overallScore,
              reasoning: overallReasoning
            });
            console.log('[SmartTable] Stored critic data for idea:', evaluation.ideaId, {
              criticalAnalysis: evaluation.criticalAnalysis.substring(0, 50) + '...',
              overallScore: evaluation.overallScore
            });
          } else {
            console.log('[SmartTable] CriticAgent event did not contain valid evaluation data', {
              hasMetadata: !!event.metadata,
              hasData: !!event.metadata?.data,
              hasEvaluation: !!criticData?.evaluation,
              evaluation: criticData?.evaluation
            });
          }
        } catch (error) {
          console.error('[SmartTable] Error processing CriticAgent event:', error);
        }
      } else if (event.agentName === "DocumentationAgent") {
        console.log('[SmartTable] Received DocumentationAgent event:', event.type, event);
        try {
          if (event.type === "progress") {
            // Parse DocumentationAgent progress events - contains individual idea documentation paths
            const progressData = event.metadata?.data as {
              ideaId?: string;
              index?: number;
              total?: number;
              title?: string;
              reportPath?: string;
              [key: string]: unknown;
            };
            
            // Store the individual report path for each idea
            if (progressData?.ideaId) {
              console.log('[SmartTable] DocumentationAgent progress:', progressData.ideaId, `${progressData.index}/${progressData.total}`, progressData.title, 'reportPath:', progressData.ideaId, '.md');
              
              // Map the reportPath to the idea ID
              documentationDataMap.set(progressData.ideaId, {
                reportPath: progressData.ideaId
              });
              
              console.log('[SmartTable] Stored documentation path for idea:', progressData.ideaId);
            }
          } else if (event.type === "result") {
            // Parse DocumentationAgent result events - contains the consolidated report path
            const resultData = event.metadata?.data as {
              reportPath?: string;
              ideasProcessed?: number;
              processingTime?: number;
              [key: string]: unknown;
            };
            // DocumentationAgent creates ONE consolidated report for ALL ideas
            if (resultData?.reportPath) {
              console.log('[SmartTable] DocumentationAgent result - consolidated report path:', resultData.reportPath);
              
              // Enable the consolidated report button and store the path (stripping .md extension for consistency)
              setConsolidatedReportEnabled(true);
              const pathWithoutExtension = resultData.reportPath.replace(/\.md$/, '');
              setConsolidatedReportPath(pathWithoutExtension);
              console.log('[SmartTable] Consolidated report ready at:', pathWithoutExtension);
            }
          }
        } catch (error) {
          console.error('[SmartTable] Error processing DocumentationAgent event:', error);
        }
      }
    }
    console.log('[SmartTable] IdeaMap size:', ideaMap.size);
    console.log('[SmartTable] CompetitorDataMap size:', competitorDataMap.size);
    console.log('[SmartTable] CompetitorDataMap entries:', Array.from(competitorDataMap.entries()));
    console.log('[SmartTable] CriticDataMap size:', criticDataMap.size);
    console.log('[SmartTable] CriticDataMap entries:', Array.from(criticDataMap.entries()));
    console.log('[SmartTable] DocumentationDataMap size:', documentationDataMap.size);
    console.log('[SmartTable] DocumentationDataMap entries:', Array.from(documentationDataMap.entries()));
    
    
    // Merge competitor data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking competitor data for idea:', id);
      const competitorData = competitorDataMap.get(id);
      if (competitorData) {
        console.log('[SmartTable] Found competitor data for idea:', id, competitorData);
        // Update the idea with competitor analysis data
        idea.competitorAnalysis = competitorData.competitorAnalysis;
        idea.scores.blueOcean = competitorData.blueOceanScore;
        // Add blue ocean reasoning if not already present
        if (!idea.reasoning.blueOcean) {
          idea.reasoning.blueOcean = 'Blue Ocean score calculated based on competitor analysis';
        }
        console.log('[SmartTable] Updated idea with competitor data:', idea);
      }
    });
    
    // Merge critic data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking critic data for idea:', id);
      const criticData = criticDataMap.get(id);
      if (criticData) {
        console.log('[SmartTable] Found critic data for idea:', id, criticData);
        // Update the idea with critic evaluation data
        idea.criticalAnalysis = criticData.criticalAnalysis;
        idea.scores.overall = criticData.overallScore;
        // Update overall reasoning if provided
        if (criticData.reasoning) {
          idea.reasoning.overall = criticData.reasoning;
        }
        console.log('[SmartTable] Updated idea with critic data:', idea);
      }
    });
    // Merge documentation data with ideas
    ideaMap.forEach((idea, id) => {
      console.log('[SmartTable] Checking documentation data for idea:', id);
      const documentationData = documentationDataMap.get(id);
      if (documentationData) {
        console.log('[SmartTable] Found documentation data for idea:', id, documentationData);
        // Update the idea with documentation report path
        idea.reportPath = documentationData.reportPath;
        console.log('[SmartTable] Updated idea with documentation data:', idea);
      }
    });
    
    
    // Add starring status from local state
    const ideasWithStars = Array.from(ideaMap.values()).map(idea => ({
      ...idea,
      starred: starredIdeas.has(idea.id),
    }));

    // Sort by overall score descending, putting null scores last
    return ideasWithStars.sort((a, b) => {
      const scoreA = a.scores.overall ?? -1;
      const scoreB = b.scores.overall ?? -1;
      return scoreB - scoreA;
    });

  }, [events, starredIdeas]);

  const loading = useMemo(() => {
    // Loading is true if active and no ideas have been generated yet.
    return isActive && ideas.length === 0;
  }, [isActive, ideas.length]);

  const isStreaming = useMemo(() => {
    // Streaming is true if the process is active and we haven't received a final status event.
    const statusEvents = events.filter(e => e.agentName === 'Orchestrator' && e.type === 'status');
    const lastStatus = statusEvents[statusEvents.length - 1];
    console.log('[SmartTable] Orchestrator status event found, testing for completion message', lastStatus);
    console.log('[SmartTable] Received last event, returning streaming status');
    return isActive && lastStatus?.message !== '✅ Agent chain completed successfully!';
  }, [events, isActive]);


  const toggleStar = (id: string) => {
    setStarredIdeas(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  // Track newly added ideas for animation
  useEffect(() => {
    const prevIds = new Set(prevIdeasRef.current.map(idea => idea.id));
    const newIds = new Set<string>();

    ideas.forEach(idea => {
      if (!prevIds.has(idea.id)) {
        newIds.add(idea.id);
      }
    });

    if (newIds.size > 0) {
      setNewIdeaIds(newIds);
      setTimeout(() => setNewIdeaIds(new Set()), 2000);
    }

    prevIdeasRef.current = ideas;
  }, [ideas]);

  const filteredIdeas = ideas.filter(idea =>
    showCurrentRun ? idea.isCurrentRun : true
  );

  const handleViewConsolidatedReport = () => {
    console.log('[SmartTable] View consolidated report clicked');
    if (!consolidatedReportPath) {
      console.error('[SmartTable] No consolidated report path available');
      return;
    }

    // Extract the filename (ID) from the full path
    // Note: .md extension already stripped when storing the path
    const pathParts = consolidatedReportPath.split('/');
    const reportId = pathParts[pathParts.length - 1];
    
    console.log('[SmartTable] Opening consolidated report:', reportId);
    openDocumentation(reportId);
  };

  if (loading) {
    return (
      <Card className={cn("shadow-elegant", className)}>
        <SmartTableSkeleton rows={5} showStreamingRow={true} />
      </Card>
    );
  }

  const renderScoreCell = (
    score: number | null,
    reasoning: string,
    type: keyof typeof ScoreIcon
  ) => {
    const Icon = ScoreIcon[type];
    const isPending = score === null;
    
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className={cn(
              "score-cell flex items-center gap-1 px-2 py-1 rounded-md cursor-help",
              isPending ? "loading-shimmer" : getScoreBg(score)
            )}>
              <Icon className={cn("h-3 w-3", isPending && "opacity-50")} />
              <span className={cn(
                "font-medium text-sm",
                isPending ? "text-muted-foreground" : getScoreColor(score)
              )}>
                {score !== null ? score.toFixed(1) : "—"}
              </span>
              <Info className={cn(
                "h-3 w-3",
                isPending ? "opacity-50" : "text-muted-foreground"
              )} />
            </div>
          </TooltipTrigger>
          <TooltipContent className="max-w-xs">
            <p className="text-sm">{reasoning || "Analysis in progress..."}</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  };

  return (
    <>
      <Card className={cn("shadow-elegant", className)}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            Business Ideas Analysis
            <Badge variant="secondary" className={cn("ml-2", isStreaming && "isStreaming-pulse")}>
              {filteredIdeas.length} ideas
            </Badge>
            <Button
              variant="outline"
              size="sm"
              onClick={handleViewConsolidatedReport}
              disabled={!consolidatedReportEnabled}
              className="ml-2"
            >
              <FileText className="h-4 w-4 mr-2" />
              View consolidated report
            </Button>
          </CardTitle>
          <div className="flex items-center gap-2">
            <Filter className="h-4 w-4 text-muted-foreground" />
            <Label htmlFor="filter-toggle" className="text-sm">Current run only</Label>
            <Switch id="filter-toggle" checked={showCurrentRun} onCheckedChange={setShowCurrentRun} />
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-0">
        <div className="smart-table-container">
          <Table className="smart-table">
            <TableHeader>
              <TableRow className="bg-muted/50">
                <TableHead className="w-12"></TableHead>
                <TableHead className="w-12">#</TableHead>
                <TableHead className="min-w-[200px]">Idea</TableHead>
                <TableHead className="w-24">Overall</TableHead>
                <TableHead className="w-24">Disruption</TableHead>
                <TableHead className="w-24">Market</TableHead>
                <TableHead className="w-24">Technical</TableHead>
                <TableHead className="w-24">Capital</TableHead>
                <TableHead className="w-24">Blue Ocean</TableHead>
                <TableHead className="min-w-[150px]">Competitor Analysis</TableHead>
                <TableHead className="min-w-[150px]">Critical Analysis</TableHead>
                <TableHead className="w-32">Report</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredIdeas.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={12} className="text-center py-8 text-muted-foreground">
                    {isActive ? "Generating ideas..." : "No ideas generated yet. Start by filling out the form above."}
                  </TableCell>
                </TableRow>
              ) : (
                filteredIdeas.map((idea, index) => (
                  <TableRow
                    key={idea.id}
                    className={cn(
                      "hover:bg-muted/50 transition-colors",
                      newIdeaIds.has(idea.id) && "new-idea-glow"
                    )}
                  >
                    <TableCell>
                       <Button variant="ghost" size="sm" onClick={() => toggleStar(idea.id)} className="h-8 w-8 p-0 group">
                         <Star className={cn("h-4 w-4 transition-colors", idea.starred ? "fill-yellow-400 text-yellow-400" : "text-muted-foreground group-hover:text-yellow-400")} />
                       </Button>
                    </TableCell>
                    <TableCell className="font-medium text-sm">{String(index + 1).padStart(2, '0')}</TableCell>
                    <TableCell>
                      <div className="space-y-1">
                        <div className="font-semibold text-sm">{idea.title}</div>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild><div className="text-xs text-muted-foreground cursor-help">{truncateText(idea.description, 100)}</div></TooltipTrigger>
                            <TooltipContent className="max-w-md"><p>{idea.description}</p></TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </div>
                    </TableCell>
                    <TableCell>{renderScoreCell(idea.scores.overall, idea.reasoning.overall, 'overall')}</TableCell>
                    <TableCell>{renderScoreCell(idea.scores.disruption, idea.reasoning.disruption, 'disruption')}</TableCell>
                    <TableCell>{renderScoreCell(idea.scores.market, idea.reasoning.market, 'market')}</TableCell>
                    <TableCell>{renderScoreCell(idea.scores.technical, idea.reasoning.technical, 'technical')}</TableCell>
                    <TableCell>{renderScoreCell(idea.scores.capital, idea.reasoning.capital, 'capital')}</TableCell>
                    <TableCell>{renderScoreCell(idea.scores.blueOcean, idea.reasoning.blueOcean, 'blueOcean')}</TableCell>
                    <TableCell><TooltipProvider><Tooltip><TooltipTrigger asChild><div className="text-xs cursor-help">{truncateText(idea.competitorAnalysis || "Analysis pending...")}</div></TooltipTrigger><TooltipContent className="max-w-md"><p>{idea.competitorAnalysis || "Competitor analysis is being generated..."}</p></TooltipContent></Tooltip></TooltipProvider></TableCell>
                    <TableCell><TooltipProvider><Tooltip><TooltipTrigger asChild><div className="text-xs cursor-help">{truncateText(idea.criticalAnalysis || "Analysis pending...")}</div></TooltipTrigger><TooltipContent className="max-w-md"><p>{idea.criticalAnalysis || "Critical analysis is being generated..."}</p></TooltipContent></Tooltip></TooltipProvider></TableCell>
                    <TableCell>
                      <Button
                        variant={idea.reportPath ? "outline" : "ghost"}
                        size="sm"
                        onClick={() => openDocumentation(idea.id)}
                        disabled={!idea.reportPath || docLoading}
                        className="h-8"
                      >
                        <FileText className="h-3 w-3 mr-1" />
                        {idea.reportPath ? "View" : "Pending"}
                      </Button>
                    </TableCell>
                  </TableRow>
                ))
              )}
              {isStreaming && ideas.length > 0 && (
                <TableRow className="bg-blue-50/50 animate-pulse">
                  <TableCell colSpan={12} className="text-center py-2">
                    <div className="flex items-center justify-center gap-2">
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                      <div className="h-2 w-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                      <span className="text-sm text-blue-600 ml-2">Analysis in progress...</span>
                    </div>
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
    
    <MarkdownViewerModal
      isOpen={isOpen}
      title="Business Idea Documentation"
      content={content}
      onClose={closeDocumentation}
    />
    </>
  );
}